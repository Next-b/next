/*
	base64-format
*/

var R = require("ramda");
var escapeString = require("js-string-escape");
var escapeRegex = require("escape-string-regexp");

var variants = require("./variants.json");

var defaults = {
	from: "base64",
	to: "base64",
	targets: [
		"i62", 
		"i63", 
		"pad"
	],
	parse: true,
	swapFromAndTo: true,
	data: undefined,
}


/*
	Functionality
*/

var changeDefaults = function (options) {
    defaults = R.mixin(defaults, options);
    return formatter;
}

// Resolve variant from/to names
var variant = function(o) {
	return {
		from: variants[o.from],
		to: variants[o.to]
	}
}

var swapFromAndTo = function (o) {
	if (!o.swapFromAndTo) return o;
	return R.mixin(o, {
		from: o.to,
		to: o.from
	});
}

// Validate input formats
var validate = function (o) {
	var v = variant(o);
	// Check target lengths (<= 1)
	// Iterate through target directions
	R.keys(v).forEach(function (direction) {
		// Iterate through targets
		R.keys(direction.targets).forEach(function (target) {
			if (target.length > 1) {
				throw new Error(
					"Expected <= 1 characters: " +
					o[direction] + ".targets." + target
				);
			}
		});
	});
	return o;
}

// Parse o.data, conformant to o.from
var parseData = function (o) {
	if (!o.parse) return o;
	var fuse = R.join("");
	// Build a partial regular expression from from.targets
	var regex = R.pipe(R.values, fuse, escapeRegex)(variant(o).from.targets);
	// Delete every char except a-z, A-Z, 0-9, from.targets
	var parse = R.replace(new RegExp("[^A-Za-z0-9" + regex + "]", "g"), "");
	o.data = parse(o.data);
	return o;
}

var formatTargets = function (o) {
	var v = variant(o);
	o.targets.forEach(function (target) {
		if (!v.from.targets[target] && o.warnings) {
			throw new Error("variants.targets." + target + " not defined");
		}
		if (!v.from.targets[target]) return false;
		o.data = o.data
			.replace(
				new RegExp("\\"+v.from.targets[target], "g"), 
				v.to.targets[target]
			);
	});
	return o;
}

var formatLines = function (o) {
	var v = variant(o);
	// Remove separators
	if (v.from.line.separator) {
		o.data = o.data
			.replace(new RegExp(escapeString(v.from.line.separator), "g"),	"");
	}
	// Add separators
	if (v.to.line.length) {
		o.data = o.data
			// Split o.data into array of segments
			.match(new RegExp(".{1," + v.to.line.length + "}", "g"))
			// Join segments with separator
			.join(v.to.line.separator);
	}
	return o;
}

// Facade for functional programming
var functional = function (options) {
	return process(R.mixin(defaults, options));
}

var process = R.pipe(validate, parseData, formatTargets, formatLines, swapFromAndTo);

/*
	Exports
*/

// Facade for imperative programming
var formatter = function (data, options) {
	o = R.mixin(defaults, options); // , { data: data }
	o.data = data;
	return process(o).data;
}

// For functional programming
formatter.functional = functional;

formatter.defaults = changeDefaults;
formatter.variants = variants;

if (typeof module !== "undefined") {
	module.exports = formatter;
}
